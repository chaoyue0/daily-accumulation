# React

## 特点

- 单向数据流，State --> View --> New State --> New View
- 状态驱动视图
- view = fn(state)模型
- JSX+inline style，`渲染逻辑`和`标签`共同存在与`组件`中，HTML和CSS全部写进JavaScript中
  - 每个React组件都是一个JavaScript函数，它会返回一些标签，后将标签渲染到浏览器上

## 描述UI

### 组件
一段可以用标签进行扩展的JavaScript函数

#### 导出组件
export default

#### 定义函数
React组件是常规的js函数，但是组件的名称必须`以大写字母开头`，否则无法运行

#### 添加标签
使用JSX语法在js中嵌入使用标签

    如果标签和return不在同一行，需要把它包裹在一对括号中，否则return下一行的代码会被忽略

### 组件的导入和导出
导出：一个文件里有且仅有一个组件默认导出(export default)，有任意多个具名导出(export)

导入：对应默认导出直接import函数名，对应具名导出使用按需导入的方式(`{}`)

### JSX

#### 定义
是JavaScript的语法扩展，可以很好的描述UI交互的本质形式

#### React组件与HTML标签
React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签

- 渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名
- 渲染 React 组件，只需创建一个大写字母开头的本地变量

#### 规则
##### 只能返回一个根元素
如果一个组件包含多个元素，需要使用一个父标签把它们包裹起来，可以使用<div>标签或者`<> 和 </>`来代替

    这个空标签被称为Fragment，不会在HTML结构中添加额外节点

原理：JSX本质上在底层被转化为JavaScript对象，不能在一个函数中返回多个对象，除非用一个数组把它们包起来

##### 标签必须闭合

- 开始标签必须带有闭合标签
- 单标签必须写成自闭合标签

##### 使用驼峰命名法给大部分属性命名
JSX中的属性会变成JavaScript对象中的键值对，对对象的命名存在限制要求，如不能包含-或不能使用class保留字(class用className代替)

##### 动态绑定标签属性
使用`{}`代替`“”`来使用js变量

    对象也用大括号表示，即两对大括号，如style属性名需要符合驼峰命名法编写，且用双大括号包裹

### 将Props传递给组件
每个父组件可以提供props传递给子组件

#### 在父组件中传递
将属性直接写在子组件标签内，数值值用{}

#### 在子组件中读取
将属性直接写在函数的参数列表中，用{}包裹，也可以直接写props解构方式


#### prop默认值
在参数后面写=和默认值进行解构

#### 展开语法传递props
重视简洁，可以使用...props，将所有的props属性传递给子组件

#### props不可变

### 条件渲染

- if选择 if()
- 三目运算符 ? :
- 与运算符 &&

### 渲染列表

#### React中为什么需要key
即使元素的位置在渲染的过程中发生了变化，它提供的key值也能让React在整个生命周期中一直找到

    React会默认将数组项的索引当作key值使用，但是数组项的插入、删除或者重新排列会产生bug，同时也不要在运行过程中动态产生key，会导致所有的组件和DOM元素都要重新创建

### 保持组件纯粹
#### 纯函数

- 只负责自己的任务
- 输入相同，则输出相同

好处：

- 组件可以在不同的环境下运行：一个组件可以满足多个用户请求
- 对于输入未改变的组件可以跳过渲染，提高性能（缓存）
- 在渲染深层组件树的过程中，数据发生改变React可以重新开始渲染，而无需浪费时间完成过时的渲染
#### 副作用
React的渲染过程必须自始至终是纯粹的，后果是可预期的

#### 局部mutation
突变：组件改变了预先存在的变量的值

纯函数不会改变函数作用域外的变量，或在函数调用前创建的对象

    可以在渲染时更改你刚刚创建的变量和对象，渲染是一种 计算过程 ，它不应该试图“做”其他事情

### 将UI视为树
树是项目和UI之间的关系模型，通常使用树结构来表示UI

## 添加交互
### 响应事件
事件处理函数：

- 通常在组件内部定义
- 名称以handle开头，后跟事件名称
#### 添加事件
- 定义一个函数，将其作为prop传入合适的JSX标签
- 按照惯例，事件处理函数`props名`应该以on开头后跟一个大写字母
#### 事件传播
事件处理函数将捕获任何来自子组件的事件，事件会沿着树向上冒泡

##### 阻止传播
事件函数接收一个事件对象（e）作为唯一的参数，该对象允许阻止传播（e.stopPropagation()）

    e.preventDefault()：阻止少数事件的默认浏览器行为

### state：组件的记忆
#### 背景

- 局部变量无法在多次渲染中持久保存，再次渲染会`重新渲染`，而不会考虑之前对局部变量的任何更改
- 更改局部变量不会触发渲染，不会意识到需要使用`新数据`再次渲染组件

#### useState

- State变量：用于保存渲染间的数据
- State setter函数：更新变量并触发React再次渲染组件、

#### Hook
以`use开头`的函数都称为Hook，只在渲染时有效，能让你hook到不同的React特性中

    Hook函数只能在组件或自定义Hook的最顶层调用，类似于在文件顶部导入模块

#### State是隔离且私有的
如果渲染同一个组件两次，每个副本都会有完全隔离的state，改变其中一个不会影响另一个

#### 特性
一个state变量的值永远不会在一次渲染的内部发生变化，即使事件处理函数是异步代码，无需担心代码运行时state是否发生了变化

### 渲染和提交
组件显示到屏幕之前，其必须被React渲染

- 触发一次更新
- 渲染组件（状态更新时重新渲染）
- 提交到DOM（渲染结果和上次一样，React不会修改DOM）