# 性能优化
从过程趋势来看，性能优化可以分为`网络层面`和`渲染层面`；从结果趋势来看，性能优化可分为`时间层面`和`体积层面`

## 网路层面
### 构建策略
主要围绕webpack做相关处理，常见的优化就是拆包、分块、压缩等
#### 减少打包时间
##### 缩减范围
配置`include/exclude`缩小Loader对文件的搜索范围，可以避免不必要的编译
##### 缓存副本
配置`cache`缓存，加快构建速度
```
 cache: {
      type: 'filesystem',
      allowCollectingMemory: true,
    },
```
##### 定向搜索
配置`resolve`提高文件的搜索速度,alias映射模板路径，extensions表明文件后缀
```
  resolve: {
    alias: {
        '@':'C:\\Users\\jiayu01\\WebstormProjects\\fba_admin_vue3\\src',
         vue$:'vue/dist/vue.runtime.esm-bundler.js'
    }
,
    extensions: [
        '.tsx',
        '.ts',
        '.mjs',
        '.js',
        '.jsx',
        '.vue',
        '.json',
        '.wasm'
    ],
}
```
##### 并行构建
配置`Thread`将Loader单进程转换为多进程，释放CPU多核并发的优势

使用`thread-loader`开启多线程，开启一个线程的处理时间`600ms`(仅在耗时的loader上使用)，使用方法只要把thread-loader放置在其他loader之前，
这样thread-loader之后的loader就会在一个单独的`worker池`中运行

    产生的worker数量，默认是cpu核心数 - 1
##### 可视结构
配置`BundleAnalyzer`分析打包文件结构，直观分析打包文件的模块组成部分、模块体积占比、模块包含关系、模块依赖关系、文件是否重复、压缩体积对比等可视化数据

#### 减少打包体积
##### 分割代码
将一个大的js文件分割成多个较小的代码块，将公共的代码抽离成单独的chunk，避免资源重复打包，
在需要的时候按需加载 ，并充分利用浏览器的缓存机制，缩短资源加载时间

- module：应用程序的一个单独的模块，webpack将每一个模块视为一个独立的单元，并通过识别模块之间的依赖关系来构建应用程序
- chunk：一组相互依赖的module，组合在一起即可并行加载，浏览器可同时加载多个chunk而不是一个大文件
- bundle：包含一个或多个chunk和其他资源文件

        module、chunk、bundle其实是同一份代码在不同转换场景的三种webpack术语，源文件是module，webpack处理时是chunk，浏览器可以直接运行的是bundle
###### 移除重复的代码块
使用 splitChunks 的 `cacheGroups` 配置：

- reuseExistingChunk属性重用模块，而不是重新生成
- enforce：表示是否强制拆分

###### 将PNPM包拆分为体积适中的chunk
vue cli默认的webpack配置已经完成了此项配置，移除了node_module包中的重复模块
##### 摇树优化
使用`import`导入模块，使用`export`导出模块 

    Tree Shaking在生产环境下默认启动

如果想在开发环境启动Tree Shaking，需要配置optimization.usedExports为true，在 Webpack 编译过程中启动标记功能

原理：它会将每个模块中没有被使用过的导出内容标记为`unused`，当生成产物时，被标记的变量对应的导出语句会被删除
##### 动态垫片
polyfill：降级\替代方案，指可以将ES6+的API转换成在低版本的浏览器上可以实现相同功能的替换实现
##### 按需加载
将路由页面、触发性功能单独打包为一个文件，使用时才加载，减轻首屏渲染的负担
##### 压缩资源
###### html压缩
html-wepack-plugin插件，可以压缩html

###### css压缩
optimize-css-assets-webpack-plugin插件，可以压缩css

    如果要在开发环境也进行css压缩，需要将minimize配置属性设为true

###### js压缩
terser-webpack-plugin插件，可以压缩js

    在webpack v5中是开箱即用的，如果需要自定义配置的话需要引入该插件

### 图像策略
#### 图像选型
了解所有图像类型的特点及其其何种应用场景最合适

| 类型       | 体积 | 质量 | 兼容性 | 请求 | 压缩   | 透明  | 场景                                 |
|----------|----|----|-----|----|------|-----|------------------------------------|
| JPG\JPEG | 小  | 中  | 好   | 是  | 有损压缩 | 不支持 | 色彩丰富图、背景图、头像<br />(不适合含文字图像，影响可读性) |
| PNG      | 大  | 高  | 好   | 是  | 无损压缩 | 支持  | 信息图表以及包含图像和文本的图形、屏幕截图              |
| WebP     | 小  | 中  | 差   | 是  | 有损、无损压缩 | 支持  | JPEG和PNG文件最佳替代格式，可节省带宽并提升网站加载速度    |
| SVG      | 小  | 高  | 好   | 是  | 无损压缩 | 支持  | logo、矢量图，不建议复杂图像                   |
#### 图像压缩
在部署到生产环境前使用工具或脚本对其压缩处理

常用的工具：QuickPicture、TinyPng
### 分发策略
主要围绕`内容分发网络`做相关处理，购买CDN服务

原理：一组分布在各地存储数据副本并可根据`就近原则`满足数据请求的服务器，核心是`缓存`和`回源`

- 缓存:是把资源复制到CDN服务器里
- 回源：资源过期\不存在就向上层服务器请求并复制到CDN服务器里


    所有静态资源走CND：开发阶段确定哪些文件属于静态资源(不常变化的样式文件、脚本文件和多媒体文件，如字体、图像、音频、视频)
### 缓存策略
主要围绕浏览器缓存

## 渲染层面
### css策略

- 避免出现超过三层的嵌套规则
- 避免为ID选择器添加多余选择器
- 避免使用标签选择器代替类选择器
- 避免重复匹配重复定义，关注可继承属性
### DOM策略

- 缓存DOM计算属性
- 避免过多DOM操作
### 阻塞策略

- 脚本与DOM的依赖关系很强，对script标签设置defer
- 脚本与DOM的依赖关系不强，对script标签设置async
### 回流重绘策略

- 使用类合并样式，避免逐条改变样式
- 使用display控制DOM显示隐藏，将DOM离线化，而不是改变DOM树
- 缓存DOM计算属性
### 异步更新策略
在异步任务中修改DOM时，把其包装成微任务(promise、nextTick)

## 开发层面

### 自动刷新
#### 监听文件变更
##### 方式一 webpack.config.js
在webpack.config.js中设置`watch: true`

原理：递归解析出entry文件所依赖的文件，把这些依赖的文件加入到监听列表，而不是直接监听项目目录下的所有文件，
定时的不停地去获取文件的最后编译时间，每次都存下最后编译时间，如果发现获取的和最后一次保存的编译时间不一致，就认为文件发生了变化，
监听到文件发生变化时，不会自立即告诉监听者，先缓存起来，收集一段时间的变化后，再一次性告诉监听者，防止文件更新太快导致编译频繁，程序构建卡死

watchOptions：

- ignored：不监听的文件或文件夹，支持正则匹配
- poll：控制定时检查的周期，默认是1000ms
- aggregateTimeout：配置等待时间，默认300ms

##### 方式二 打包命令
在执行启动 Webpack 命令时，带上 `--watch` 参数，完整命令是 webpack --watch

#### 监听浏览器自动更新

### 模块热替换
不刷新整个网页的情况下做到超灵敏的实时预览

#### 方式一 webpack.config.js
安装HotModuleReplacementPlugin插件，在devServer配置项下增加`hot: true`属性

#### 方式二 打包命令
在执行启动 Webpack 命令时，带上 `--hot` 参数，完整命令是webpack-dev-server --hot

### 热模块替换与自动更新

- 相同点：向网页注入一个代理服务器的方式，连接devServer及网页
- 不同点：
  - 自动更新：网页自动刷新
  - 热模块替换：模块替换机制

## 优化标准
目的：希望降低程序的`整体开销`，应该把重点放在对程序`整体开销影响最大`的那部分上

原则：评估优先，拒绝任何不能提供良好效益的优化，浏览器通常在运行js上花费的时间很少，绝大部分时间消耗在DOM上

### 性能指标

- 文档加载过程
- 文档渲染呈现过程
- 交互过程

#### 文档加载过程
应用缓存、DNS解析、TCP握手、HTTP请求处理、HTTP响应处理、DOM处理、文档加载完成

##### TTFB (Time to First Byte)
是发出页面请求到接收到应答数据第一个字节所花费的毫秒数，包括DNS查询、TCP连接和SSl连接

    不仅仅是在服务器上花费的时间，还包括设备请求发送到服务器，再从服务器返回到设备的时间

##### DCL
初始HTML文档被完全加载和解析完成，会触发DCL事件，而无需等待样式表、图像和子框架的完全加载

#### 文档渲染呈现过程
##### FP & FCP

- FP：首次绘制，表示页面第一次绘制像素的时间
- FCP：首次内容绘制，标识页面首次绘制文本、图片、非空白Canvas或SVG的时间

##### FMP
指的是首要内容出现在屏幕上的时间，如标题、首屏内容、图片

##### LCP
指的是最大内容绘制，用于记录视窗内最大的元素绘制时间，该指标会在用户第一次交互后停止记录

    LCP在2.5秒内标识体验优秀，2.5-4秒表示需要优化，超过4秒表示体验差

#### 交互过程

##### TTI
表示网页首次完全达到可交互状态的时间点

##### FID
表示首次输入延迟，用于记录在FCP和TTI之间用户首次与页面交互时响应的延迟，指的是用户交互事件触发到页面响应中间耗时多少，
如果其中有长任务发生的话必定会造成响应时间变长

### 性能指标轴线

- 低效线：会降低用户的关注度，并使用户烦躁不安
- 受挫线：用户会意识到自己在被迫等待，导致用户开始考虑其他事情
- 失败线：由于应用崩溃或浏览器产生一个对话框告诉用户应用失败，用户只能刷新或关闭浏览器

### 性能指标时间点
如何才算“足够快”

- 0.1秒：用户直接操作UI中对象的感觉极限
- 1秒：用户随意地在计算机指令空间进行操作而无需过度等待地感觉极限，超过1秒地延时要提示用户计算机正在处理问题，例如loading
- 10秒：用户专注于任务的极限，需要一个百分比完成指示器，以及一个方便用户中断操作的方法

### 测试原则
测试用户环境，使用低端机器和低速网络来测试，在开发人员的高配置环境中得出的测试结果还可能会掩盖性能问题

### 测试延时时间

- 手动代码检查：代码中添加`计时器`记录函数的`执行时间`
- 自动代码检测：通过`工具`进行`性能分析`，查找瓶颈或运行最慢的代码块


    工具：Firefox插件Firebug包含一个js代码性能分析器（已下架）

## 大文件上传

### 文件切片
定义：将上传的文件按照一定的大小，将整个文件分隔成多个数据块来进行分片上传，上传完之后再由服务器对所有上传的文件进行汇总整合成原始的文件

#### 流程
1、将需要上传的文件按照一定的分割规律，分成相同大小的数据块

2、初始化一个分片上传任务，返回本次分片上传的唯一标识(`使用md5实现文件的唯一性`)

3、按照一定的策略(串行或并行)发送各个分片数据块

4、发送完毕之后，服务端根据判断数据上传是否完整，如果完整则数据块合并得到原始文件

#### 缺点

- 无法识别一个切片属于哪一个切片，当同时发生多个请求时，追加的文件内容可能出错
- 切片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接的
### 切片还原
#### 识别切片
在每个切片请求时传递一个相同文件的`context`参数(文件的唯一标识)

    FileReader对象允许Web应用程序异步读取存储在用户计算机上的文件(或数据缓存区)的内容，生成的实例有一系列文件相关的属性和方法

- 根据文件名、文件长度等基本信息进行拼接，再额外拼接用户信息如uid等保证唯一性
- 根据文件的二进制内容计算文件的hash，缺点在于计算量大
#### 还原文件
1、当所有切片都已上传，通知服务端进行拼接

2、找到同一个context下的所有切片，确定每个切片的顺序(在每个切片上标记一个位置索引值)

3、按顺序拼接切片，还原成文件
### 断点续传
#### 需求
即使将大文件拆分成切片上传，仍需要等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情况，如网络故障、页面关闭等

#### 定义
可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间

#### 实现

- 在切片上传成功后，保存已上传的切片信息
- 当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传
- 所有切片上传完毕后，再通知服务端进行文件合并

#### 保存切片信息

- 通过localStorage等方式保存再前端浏览器中
- 由服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的上传记录
### 文件秒传
#### 定义
指的是后端已经存在了上传的文件，所以再次上传时会直接提示上传成功

#### 原理
在文件上传前，先计算出文件的hash，先把hash发送给后端验证，如果后端找到了hash相同的文件，则直接返回上传成功的信息即可

### 优化
#### 超大文件hash计算时间过长
采用抽样思路来计算hash，放弃一部分准确度来换取时间

- 将超大文件以2M进行分割获得chunks数组
- 第一个元素和最后一个元素保存下来
- 将其他元素进行再次分割，这次分割的是超小的大小比如2kb
- 选取第一个元素和最后一个元素以及中间的2kb组成一个新的文件