## 每日积累
### 对象属性访问
- 点号(`.`)
- 中括号(`[]`)

通常使用点号来访问对象的属性，当对象的属性需要使用变量或表达式来`动态确定`就可以使用中括号来访问；

### Object.freeze
定义：用于冻结一个对象，使其变为不可修改的，包括对象内部的属性以及嵌套对象都不可修改；

### 类型判断
- typeof
- instanceof
- Object.prototype.toString.call()

#### typeof
定义：用来判断基本类型；

原理：变量是以二进制的形式存储在计算机中，typeof操作符根据变量的前3位二进制判断变量的类型，如000表示的是Object；

注意点：遇到引用类型会统一返回Object，除了函数返回Function，判断基本类型的`null`也会返回Object；

#### instanceof
定义：用来判断引用类型，检查一个对象是否是某个类（或其父类）的实例；

原理：判断该对象的原型链上是否有该类的原型对象；

注意点：不能判断基本类型，如果对象或者类在不同的窗口(window)或者框架(frame)中，会返回false；

#### Object.prototype.toString.call()
定义：属于js内置对象的一个方法，用于返回一个表示对象的字符串，常用来判断对象的类型；

原理：重写了不同类型对象的toString方法，将类型对象作为上下文，返回`[Object 类型]`，其中类型是对象内部属性`[[class]]`的值;

注意点：针对基本类型判断，会将其封装为对应的`包装对象`，然后再返回该包装对象的类型字符串，不适用判断基本类型，返回[Object String]而不是string；

### 数组遍历方法
#### forEach与map的区别
相同点：

当数组元素是基本数据类型时，不会改变原数组；当数组元素是引用类型时，会改变原数组；

    原理：数组遍历相当于拷贝一份新的数据进行处理操作，当处理的数据是基本类型时，拷贝的两份数据没有关联互不影响；
        但当处理的数据是引用类型时，涉及浅拷贝的概念，引用类型拷贝的数据是在堆空间的值，两份数据共同指向同一个地址，两者会相互影响；

不同点：

- forEach表示遍历数组中的每个元素，针对每个元素执行指定的操作，没有返回值；
- map表示遍历数组中的每个元素，针对每个元素执行指定的操作，将执行结果放入到一个新数组中，并返回这个新数组；

### 为什么promise可以开启一个异步队列
当创建一个promise对象时，它会立即进入一个pending状态，此时表示promise正在执行异步操作。
当异步操作执行完毕之后，调用resolve方法将pending改变成fulfilled，调用reject方法改变成rejected。

#### 链式调用
通过then方法，注册回调函数。按照then的顺序形成promise链，确保异步操作的顺序和处理；

#### promise.all实现的原理
1、该方法接受一个可迭代对象作为参数，并返回一个promise对象；

2、在内部创建一个计数器变量，用来跟踪状态已经改变的promise对象的数量；

3、遍历可迭代对象，检测是否为promise对象，如果是，就组册一个then方法，用来处理已经解决的promise对象；

4、每当可迭代对象中的promise状态改变，则将计数器变量加一；

5、如果所有的promise对象都解决(计数器的值等于可迭代对象的长度)，则新的promise对象状态改变成fulfilled；

6、如果其中promise对象被拒绝，则新的promise立即被拒绝；

7、最后，返回新的promise对象；

#### promise.race实现的原理
1、该方法接受一个可迭代对象作为参数，并返回一个promise对象；

2、在内部创建一个解决函数和拒绝函数，用于将新的promise对象置为解决或拒绝状态；

3、遍历可迭代对象，检测是否为promise对象，如果是，就组册对象的then方法和catch方法；

4、当任何一个promise对象被解决就调用解决函数，并将新的promise对象置为已解决；

5、当任何一个promise对象被拒绝就调用拒绝函数，并将新的promise对象置为已拒绝；

6、最后，返回新的promise对象；

### defer和async
    与页面渲染过程知识点相关
#### defer
- 表示脚本的加载是异步的，并且会延时执行脚本，直到整个文档解析和显示完成后再执行；
- 多个defer属性按照在文档中出现的顺序依次加载，并在文档解析完成后按照在文档中的顺序依次执行；
- 保证脚本的加载是异步的，但执行顺序是有序的；

#### async
- 表示脚本的加载是异步的，不会阻塞文档的解析和渲染过程；
- 脚本的加载和执行是并行的，一旦脚本下载完成立即执行；
- 多个async属性，加载和执行顺序是不确定的，取决于网速和脚本的下载顺序；
- 脚本的加载和执行都是异步的，但加载和执行的顺序不确定；

### https和http的区别

https在http的基础上增加SSL组成了以安全为目标的http通道；

#### 加密方式
- 对称加密

使用同一个密钥来进行加密和解密，就是通信双方使用同一个密钥，一方加密发送信息，一方解密获取信息；

步骤：

1、A通信方将密钥发送给B通信方

2、B通信方使用密钥将信息加密后发送给A

3、A使用密钥解密B发送过来的加密信息
- 非对称加密

通过一个公钥进行加密，然后通过私钥进行解密；

步骤：

1、A将自己的公钥发送给B；

2、B将自己的公钥发送给A；

3、B使用A的公钥加密信息发送给A；

4、A使用自己的私钥进行解密信息，得到原始信息；

5、A使用B的公钥加密信息发送给B；

6、B使用自己的私钥进行解密信息，得到原始信息；

#### HTTPS加密方式

采用非对称+对称组合加密；传输数据的加密方式采用对称加密，对`对称密钥`的传输采用非对称加密；

步骤：

1、A将自己的公钥发送给B；

2、B将自己的公钥发送给A；

3、B生成随机对称密钥并使用A的公钥加密信息发送给A；

4、A使用自己的私钥解密信息，得到`对称密钥`；(非对称加密使用私钥解密得到原始信息)

5、双方通过后，使用对称密钥进行通信；
### 304 协商缓存
定义：当客户端发送带有缓存验证信息的请求时，服务器可以通过返回304表示请求的资源未发送改变，
客户端可以继续使用缓存的版本，无需重新下载资源；

工作原理：

1、客户端发送带有缓存验证信息的请求给服务器；(If-Modified-Since和If-None-Match)；

2、服务器收到请求后，检查缓存验证信息和资源上的验证信息是否匹配；(缓存验证信息确实没有改变，但是服务器资源发送了改变，导致不匹配)

3、如果服务器发现资源自上次请求以来没有变化，则返回304；

4、客户端收到304响应后，就会使用本地的缓存信息，而不是重新下载资源；

### call、apply、bind
#### call
定义：call作为Function对象原型上的方法，所有的实例函数都可以调用该方法。
表示使用一个指定的this值和给出一个或多个参数来调用函数；

例：fn.call(null, obj[i], i, obj)

- fn是待调用的函数；
- null表示函数内部this的指向，null或者空表示没有指定this值，因此函数内部的this会指向全局，也就是window对象；
- obj[i]、i、obj都作为传递给fn函数的参数；

#### apply
定义：与call用法相同，但是传递的参数是数组字面量或者数组对象；

#### bind
定义：创建一个函数副本，并改变调用函数内部的this值；

### 赋值、浅拷贝、深拷贝
深、浅拷贝都是相对于引用类型而言，基本类型没有深、浅拷贝的说法；

#### 赋值
对象直接赋值，新对象和原对象指向的是同一个对象；

对于对象中的基本类型数据，改变数据会使原数据也发送改变，而对象中的子对象，改变也会使原数据一同发生变化；

#### 浅拷贝
定义：将对象的每个属性依次进行复制，当遇到引用类型属性时，实质复制的是引用地址，浅拷贝前后对象的值会相互影响；

方式：
- Object.assign
- 扩展运算符
- Array.prototype.slice()
- Array.prototype.concat()

#### 深拷贝
定义：复制对象中的属性，遇到引用类型会一直递归直到基本类型，再进行复制，深拷贝前后对象的值是完全隔离的，互不影响；

方式：
- JSON.parse(JSON.stringify())