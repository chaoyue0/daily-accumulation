## 每日积累
### 对象属性访问
- 点号(`.`)
- 中括号(`[]`)

通常使用点号来访问对象的属性，当对象的属性需要使用变量或表达式来`动态确定`就可以使用中括号来访问；

### Object.freeze
定义：用于冻结一个对象，使其变为不可修改的，包括对象内部的属性以及嵌套对象都不可修改；

### 类型判断
- typeof
- instanceof
- Object.prototype.toString.call()

#### typeof
定义：用来判断基本类型；

原理：变量是以二进制的形式存储在计算机中，typeof操作符根据变量的前3位二进制判断变量的类型，如000表示的是Object；

注意点：遇到引用类型会统一返回Object，除了函数返回Function，判断基本类型的`null`也会返回Object；

#### instanceof
定义：用来判断引用类型，检查一个对象是否是某个类（或其父类）的实例；

原理：判断该对象的原型链上是否有该类的原型对象；

注意点：不能判断基本类型，如果对象或者类在不同的窗口(window)或者框架(frame)中，会返回false；

#### Object.prototype.toString.call()
定义：属于js内置对象的一个方法，用于返回一个表示对象的字符串，常用来判断对象的类型；

原理：重写了不同类型对象的toString方法，将类型对象作为上下文，返回`[Object 类型]`，其中类型是对象内部属性`[[class]]`的值;

注意点：针对基本类型判断，会将其封装为对应的`包装对象`，然后再返回该包装对象的类型字符串，不适用判断基本类型，返回[Object String]而不是string；

### 数组遍历方法
#### forEach与map的区别
相同点：

当数组元素是基本数据类型时，不会改变原数组；当数组元素是引用类型时，会改变原数组；

    原理：数组遍历相当于拷贝一份新的数据进行处理操作，当处理的数据是基本类型时，拷贝的两份数据没有关联互不影响；
        但当处理的数据是引用类型时，涉及浅拷贝的概念，引用类型拷贝的数据是在堆空间的值，两份数据共同指向同一个地址，两者会相互影响；

不同点：

- forEach表示遍历数组中的每个元素，针对每个元素执行指定的操作，没有返回值；
- map表示遍历数组中的每个元素，针对每个元素执行指定的操作，将执行结果放入到一个新数组中，并返回这个新数组；

### 为什么promise可以开启一个异步队列
当创建一个promise对象时，它会立即进入一个pending状态，此时表示promise正在执行异步操作。
当异步操作执行完毕之后，调用resolve方法将pending改变成fulfilled，调用reject方法改变成rejected。

#### 链式调用
通过then方法，注册回调函数。按照then的顺序形成promise链，确保异步操作的顺序和处理；

#### promise.all实现的原理
1、该方法接受一个可迭代对象作为参数，并返回一个promise对象；

2、在内部创建一个计数器变量，用来跟踪状态已经改变的promise对象的数量；

3、遍历可迭代对象，检测是否为promise对象，如果是，就组册一个then方法，用来处理已经解决的promise对象；

4、每当可迭代对象中的promise状态改变，则将计数器变量加一；

5、如果所有的promise对象都解决(计数器的值等于可迭代对象的长度)，则新的promise对象状态改变成fulfilled；

6、如果其中promise对象被拒绝，则新的promise立即被拒绝；

7、最后，返回新的promise对象；

#### promise.race实现的原理
1、该方法接受一个可迭代对象作为参数，并返回一个promise对象；

2、在内部创建一个解决函数和拒绝函数，用于将新的promise对象置为解决或拒绝状态；

3、遍历可迭代对象，检测是否为promise对象，如果是，就组册对象的then方法和catch方法；

4、当任何一个promise对象被解决就调用解决函数，并将新的promise对象置为已解决；

5、当任何一个promise对象被拒绝就调用拒绝函数，并将新的promise对象置为已拒绝；

6、最后，返回新的promise对象；

### call、apply、bind
#### call
定义：call作为Function对象原型上的方法，所有的实例函数都可以调用该方法。
表示使用一个指定的this值和给出一个或多个参数来调用函数；

例：fn.call(null, obj[i], i, obj)

- fn是待调用的函数；
- null表示函数内部this的指向，null或者空表示没有指定this值，因此函数内部的this会指向全局，也就是window对象；
- obj[i]、i、obj都作为传递给fn函数的参数；

#### apply
定义：与call用法相同，但是传递的参数是数组字面量或者数组对象；

#### bind
定义：创建一个函数副本，并改变调用函数内部的this值；

### 赋值、浅拷贝、深拷贝
深、浅拷贝都是相对于引用类型而言，基本类型没有深、浅拷贝的说法；

#### 赋值
对象直接赋值，新对象和原对象指向的是同一个对象；

对于对象中的基本类型数据，改变数据会使原数据也发送改变，而对象中的子对象，改变也会使原数据一同发生变化；

#### 浅拷贝
定义：将对象的每个属性依次进行复制，当遇到引用类型属性时，实质复制的是引用地址，浅拷贝前后对象的值会相互影响；

方式：
- Object.assign
- 扩展运算符
- Array.prototype.slice()
- Array.prototype.concat()

#### 深拷贝
定义：复制对象中的属性，遇到引用类型会一直递归直到基本类型，再进行复制，深拷贝前后对象的值是完全隔离的，互不影响；

方式：
- JSON.parse(JSON.stringify())：无法解析函数

### Object.create
定义：创建一个新对象，使用现有的对象来提供新创建的对象的原型；

参数：
- proto： 新创建对象的原型对象
- propertiesObject(可选)： 指定要添加到新对象上的可枚举属性的描述符以及相应的属性名称；

### Object.defineProperty
定义：在一个对象上定义一个新属性或修改现有属性并返回此对象，可以定义或者修改属性的描述符，精确地添加或修改对象上的属性；

参数：
- obj： 定义属性的对象
- prop： 要定义或修改的属性键
- descriptor： 定义或修改的属性描述符

数据描述符：
- configurable： 表示属性不可更改且不可删除
- enumerable： 表示属性是否可枚举
- value： 与属性相关联的值
- writable： 表示value是否可以赋值运算符更改

访问器描述符：
- get： 访问该属性时，调用get函数
- set： 该属性被赋值时，调用set函数

### Object.getOwnPropertyNames
定义：接受参数是一个对象，返回一个数组，包含给定对象所有自有属性(包含不可枚举属性，但不包括使用symbol值作为名称的属性以及原型链上的属性)

注意：非对象参数会被强制转换为对象
```allykeynamelanguage
Object.getOwnPropertyNames("foo");
// ["0", "1", "2", "length"] 
```

### vue keep-alive
bug：缓存组件，没有key值无法按需删除删除组件，只有达到max值后按照队列的方式删除前段组件

### require和import区别

#### 调用时间

- require：`运行时`调用，理论上可以运作在代码的任何地方
- import：`编译时`调用，必须放在文件的开头

#### 本质

- require：赋值过程，require的结果就是对象、数值、字符串、函数等，就是普通值的拷贝传递(存在浅拷贝的情况)
- import：解构过程，使用import导入模块的属性或方法是引用传递，且import是read-only的，值是单向传递的

#### 语法

- require：导出的时候需要使用module.export后面跟着一个对象
- import：导出直接使用export，export的是一个对象(即便导出的是基本类型的数据)

### async、await优越之处
