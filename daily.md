## 每日积累

### 对象属性访问

- 点号(`.`)
- 中括号(`[]`)

通常使用点号来访问对象的属性，当对象的属性需要使用变量或表达式来`动态确定`就可以使用中括号来访问；

### Object.freeze

定义：用于冻结一个对象，使其变为不可修改的，包括对象内部的属性以及嵌套对象都不可修改；

### 类型判断

- typeof
- instanceof
- Object.prototype.toString.call()

#### typeof

定义：用来判断基本类型；

原理：变量是以二进制的形式存储在计算机中，typeof 操作符根据变量的前 3 位二进制判断变量的类型，如 000 表示的是 Object；

注意点：遇到引用类型会统一返回 Object，除了函数返回 Function，判断基本类型的`null`也会返回 Object；

#### instanceof

定义：用来判断引用类型，检查一个对象是否是某个类（或其父类）的实例；

原理：判断该对象的原型链上是否有该类的原型对象；

注意点：不能判断基本类型，如果对象或者类在不同的窗口(window)或者框架(frame)中，会返回 false；

#### Object.prototype.toString.call()

定义：属于 js 内置对象的一个方法，用于返回一个表示对象的字符串，常用来判断对象的类型；

原理：重写了不同类型对象的 toString 方法，将类型对象作为上下文，返回`[Object 类型]`，其中类型是对象内部属性`[[class]]`的值;

注意点：针对基本类型判断，会将其封装为对应的`包装对象`，然后再返回该包装对象的类型字符串，不适用判断基本类型，返回[Object String]而不是 string；

### 数组遍历方法

#### forEach 与 map 的区别

相同点：

当数组元素是基本数据类型时，不会改变原数组；当数组元素是引用类型时，会改变原数组；

    原理：数组遍历相当于拷贝一份新的数据进行处理操作，当处理的数据是基本类型时，拷贝的两份数据没有关联互不影响；
        但当处理的数据是引用类型时，涉及浅拷贝的概念，引用类型拷贝的数据是在堆空间的值，两份数据共同指向同一个地址，两者会相互影响；

不同点：

- forEach 表示遍历数组中的每个元素，针对每个元素执行指定的操作，没有返回值；
- map 表示遍历数组中的每个元素，针对每个元素执行指定的操作，将执行结果放入到一个新数组中，并返回这个新数组；

### 为什么 promise 可以开启一个异步队列

当创建一个 promise 对象时，它会立即进入一个 pending 状态，此时表示 promise 正在执行异步操作。
当异步操作执行完毕之后，调用 resolve 方法将 pending 改变成 fulfilled，调用 reject 方法改变成 rejected。

#### 链式调用

通过 then 方法，注册回调函数。按照 then 的顺序形成 promise 链，确保异步操作的顺序和处理；

#### promise.all 实现的原理

1、该方法接受一个可迭代对象作为参数，并返回一个 promise 对象；

2、在内部创建一个计数器变量，用来跟踪状态已经改变的 promise 对象的数量；

3、遍历可迭代对象，检测是否为 promise 对象，如果是，就组册一个 then 方法，用来处理已经解决的 promise 对象；

4、每当可迭代对象中的 promise 状态改变，则将计数器变量加一；

5、如果所有的 promise 对象都解决(计数器的值等于可迭代对象的长度)，则新的 promise 对象状态改变成 fulfilled；

6、如果其中 promise 对象被拒绝，则新的 promise 立即被拒绝；

7、最后，返回新的 promise 对象；

#### promise.race 实现的原理

1、该方法接受一个可迭代对象作为参数，并返回一个 promise 对象；

2、在内部创建一个解决函数和拒绝函数，用于将新的 promise 对象置为解决或拒绝状态；

3、遍历可迭代对象，检测是否为 promise 对象，如果是，就组册对象的 then 方法和 catch 方法；

4、当任何一个 promise 对象被解决就调用解决函数，并将新的 promise 对象置为已解决；

5、当任何一个 promise 对象被拒绝就调用拒绝函数，并将新的 promise 对象置为已拒绝；

6、最后，返回新的 promise 对象；

### call、apply、bind

#### call

定义：call 作为 Function 对象原型上的方法，所有的实例函数都可以调用该方法。
表示使用一个指定的 this 值和给出一个或多个参数来调用函数；

例：fn.call(null, obj[i], i, obj)

- fn 是待调用的函数；
- null 表示函数内部 this 的指向，null 或者空表示没有指定 this 值，因此函数内部的 this 会指向全局，也就是 window 对象；
- obj[i]、i、obj 都作为传递给 fn 函数的参数；

#### apply

定义：与 call 用法相同，但是传递的参数是数组字面量或者数组对象；

#### bind

定义：创建一个函数副本，并改变调用函数内部的 this 值；

### 赋值、浅拷贝、深拷贝

深、浅拷贝都是相对于引用类型而言，基本类型没有深、浅拷贝的说法；

#### 赋值

对象直接赋值，新对象和原对象指向的是同一个对象；

对于对象中的基本类型数据，改变数据会使原数据也发送改变，而对象中的子对象，改变也会使原数据一同发生变化；

#### 浅拷贝

定义：将对象的每个属性依次进行复制，当遇到引用类型属性时，实质复制的是引用地址，浅拷贝前后对象的值会相互影响；

方式：

- Object.assign
- 扩展运算符
- Array.prototype.slice()
- Array.prototype.concat()

#### 深拷贝

定义：复制对象中的属性，遇到引用类型会一直递归直到基本类型，再进行复制，深拷贝前后对象的值是完全隔离的，互不影响；

方式：

- JSON.parse(JSON.stringify())：无法解析函数

### Object.create

定义：创建一个新对象，使用现有的对象来提供新创建的对象的原型；

参数：

- proto： 新创建对象的原型对象
- propertiesObject(可选)： 指定要添加到新对象上的可枚举属性的描述符以及相应的属性名称；

### Object.defineProperty

定义：在一个对象上定义一个新属性或修改现有属性并返回此对象，可以定义或者修改属性的描述符，精确地添加或修改对象上的属性；

参数：

- obj： 定义属性的对象
- prop： 要定义或修改的属性键
- descriptor： 定义或修改的属性描述符

数据描述符：

- configurable： 表示属性不可更改且不可删除
- enumerable： 表示属性是否可枚举
- value： 与属性相关联的值
- writable： 表示 value 是否可以赋值运算符更改

访问器描述符：

- get： 访问该属性时，调用 get 函数
- set： 该属性被赋值时，调用 set 函数

### Object.getOwnPropertyNames

定义：接受参数是一个对象，返回一个数组，包含给定对象所有自有属性(包含不可枚举属性，但不包括使用 symbol 值作为名称的属性以及原型链上的属性)

注意：非对象参数会被强制转换为对象

```allykeynamelanguage
Object.getOwnPropertyNames("foo");
// ["0", "1", "2", "length"]
```

### vue keep-alive

bug：缓存组件，没有 key 值无法按需删除删除组件，只有达到 max 值后按照队列的方式删除前段组件

### require 和 import 区别

#### 调用时间

- require：`运行时`调用，理论上可以运作在代码的任何地方
- import：`编译时`调用，必须放在文件的开头

#### 本质

- require：赋值过程，require 的结果就是对象、数值、字符串、函数等，就是普通值的拷贝传递(存在浅拷贝的情况)
- import：解构过程，使用 import 导入模块的属性或方法是引用传递，且 import 是 read-only 的，值是单向传递的

#### 语法

- require：导出的时候需要使用 module.export 后面跟着一个对象
- import：导出直接使用 export，export 的是一个对象(即便导出的是基本类型的数据)

### webpack 和 vite 的区别

- webpack 是将所有的模块打包成一个 bundle 文件；而 vite 在开发模式下没有打包的过程，引用 ES Module Import 特征，只有在需要才编译文件，在生产模式下采用 rollup 打包更好的引入 tree-shaking
- webpack 全局热更新修改一次很小的改动都会重新编译整个应用；vite 增量热更新，只修改更新的部分
- webpack 有更活跃的插件市场，扩展性更强

### 事件监听

removeEventListener 清除事件监听，需要保证参数名、事件函数相同（使用箭头函数无法取消事件监听）

事件函数相同：保证是同一个函数，共享内存地址

### flex 的弊端

在容器中开启了 flex 布局，子容器会共享高度即其中一个容器高度增加会影响其他容器的高度

#### 解决方案 - grid 布局

- `grid-template-columns: auto 1fr`第一列自适应内容，第二列占据剩余空间
- 使用`grid-column`划分子容器的位置

第二列的容器高度任意改变不会影响第一列容器元素的实际高度，不会自动撑满

### 邮件 html

- 放弃 js
- 放弃外链样式和 style，使用内联样式
- 能不写 css3 就不写
- 尽量使用 table 布局
- 能不放图就不放图
- 标签尽量只用 div 和 table 标签

### canvas vs css

- 渲染方面：canvas 通过 js 在一个位图上进行逐像素绘制；css 由浏览器引擎进行优化和渲染
- 开销方面：canvas 每次重绘需要重新计算和绘制整个图像；css 会在浏览器的优化下尝试最小重绘区
- 灵活性：canvas 适用于精细控制图形渲染的场景；css 适用于简单的图形和动画
- 交互性：需要额外的 js 代码来处理用户交互；直接使用 HTML 元素的事件处理程序来实现交互，如 :hover、:active 等伪类

### canvas vs svg

- 渲染方式：svg 基于矢量的绘制技术，使用 XML 描述图形，图形可缩放不失真 graphicDisplayable
- 开销方面：适用于静态图形
- 灵活性：每个图形元素都是独立的 DOM 节点，可以方便访问和修改

### 控制边框长度-分割线

#### 需求

分割线通常显示的是部分长度，居中显示两端留白

#### 涉及知识点

- 盒模型
- 伪元素
- 定位模式

#### 实现

1、通过伪元素实现分割线样式效果，达到控制单一边框长度的效果
2、在元素之间增加 div

### 字体

- ttf：电脑轮框字体，不同字体大小像素级显示，文件体积大但兼容性好
- woff：web 开放字体格式，使用 zlib 压缩，文件体积小

### 大图优化
